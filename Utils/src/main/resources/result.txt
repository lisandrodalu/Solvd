Unique words: 435
 { on the plus side=1,  for example=1,  although feature flags are seen as ways to experiment with features=1,  errors can come halfway through the result of another operation=1,  and hides many practical details from the user=1, when a module does two things=1,  doing it again will get the same result=1,  and slowly build up through iteration=1, a system where you can delete parts without rewriting others is often called loosely coupled=1, =163,  instead of building re=1, when you know what code is going to be abandoned soon=1, by comparison=1,  a million line monolith is going to be more annoying than a ten thousand line one and significantly more time=1, instead of uuids=1,  but your system should be capable of supporting one or two experiments atop while you work out what you’re doing=1,  and state=1,  a 500 may change=1, in the same we have layered our code to separate responsibilities=1,  from platform specific to domain specific=1,  keep writing code=1, the key idea is that it is quicker to fail=1,  maybe it’s time to pull it up to a function=1,  http clients can handle many errors on the programmers behalf=1,  you won’t know how to split up your code in advance=1,  you have a fixed set of operations=1, i’m not suggesting you write the same ball of mud ten times over=1,  the more you rely on an third=1,  unless you’re psychic you won’t know how to split it up=1,  good apis are designed with empathy for the programmers who will use it=1,  when a process encounters a problem=1,  if you have any handling inside=1,  repeat yourself to avoid creating dependencies=1,  d=1, (these supervisors are started by a bootstrap process=1,  isolate the hard=1, paste code=1,  why worry that much? a little redundancy is healthy=1, the management question=1,  the programmers using your function will not rely on what you document=1, becoming a professional software developer is accumulating a back=1,  we are duplicating parts of code to avoid introducing dependencies=1,  don’t write an engine=1,  even if they aren’t protocol=1,  with new features appearing earlier in the same code base=1,  but what they observe=1, change parts from the rest of the code=1, policy=1, it isn’t so much that you’re iterating=1, the number of lines of code doesn’t tell us much on its own=1,  we are trying to keep the hard=1,  it is restarted by the bootstrap process)=1,  being able to change your mind at runtime becomes increasingly important when it can take hours=1,  they allow you to deploy changes without re=1,  money=1,  the modular bit makes it way more fun to write code=1,  and a multitude of rows to operate on=1,  loose coupling is about being able to change your mind without changing too much code=1, to write code that’s easy to delete=1,  boiler plate is a lot like copy=1,  or third party apis=1, this split of concerns allows us to make some users happy without making things impossible for other users=1,  and this allows generic timeout handling=1,  the “open a config file and give me a hash table”=1, feature flags are one way to change your mind later=1, down=1, off without recompiling=1, we are not building modules around being able to re=1, party api=1,  the more you suffer when it changes=1,  composition — are not about writing good software=1, pasted=1,  and just enough distance between the moving parts so you won’t trap your hands inside=1,  to quote perlis=1,  but the scars of bad code are fresh in your mind=1,  it exits=1, layering is less about writing code we can delete later=1,  rather than making a library function=1,  especially if you make one=1,  some problems are more intertwined and hard to separate than others=1,  requests caters to common workflows when using http=1,  layer your code too=1,  when you get a 400 error=1,  the more code you must rewrite to introduce changes=1, aside=1, the reason? sometimes it’s easier to delete one big mistake than try to delete 18 smaller interleaved mistakes=1, projects either fail or become legacy code eventually anyway=1,  you still have to do the final top level check=1,  away from the parts that are relatively static=1, when you’ve copy and pasted something enough times=1,  was the time it took to merge long lived feature branches in=1,  building simple=1, despite writing libraries to avoid copy pasting=1,  but being able to change them=1,  but the magnitude does 50=1,  it is usually because changing one part requires changing the other=1,  or which parts depend on others=1,  you should be trying to make new mistakes each time=1, in imap almost every each operation is a snowflake=1,  the stuff that ends up in a file called “util”=1, i’m not advocating you go out and create a =1,  this is fine=1,  building a pleasant to use api and building an extensible api are often at odds with each other=1,  hash tables=1,  although you can’t always swap out one database for another=1,  don’t try to do all of these things at the same time=1,  is not whether to build a pilot system and throw it away=1,  it is often easier to have one awful component with a simple interface=1, first we layered our code=1,  they found that the hardest part of keeping a regular release cycle=1,  a common set of behaviours and operations with a variety of implementations=1, using a lot of code already by just using the file=1,  you can build a library that suits your code=1, other examples of loose coupling are other systems with middleware=1, step 3=1, step 2=1, step 1=1, step 0=1, you are writing more lines of code=1,  if you’re writing your first game=1,  the easiest code to delete is the code you avoided writing in the first place=1,  retry mechanisms=1,  some redundancy=1,  except for imap=1,  and build simpler=1, step 7=1, step 6=1,  and other collections=1, step 5=1, step 4=1, system=1, ordination between them=1,  and maybe don’t write so much code in the first place=1,  many operations are not atomic=1,  fred brooks=1, if we see ‘lines of code’ as ‘lines spent’=1,  in the same way that lego bricks are fun because they all fit together=1,  and pay for it in verbosity=1, google chrome is a spectacular example of the benefits they bring=1, how your software handles failure must be taken into account when decomposing it into smaller pieces=1,  it is restarted by the supervisor=1,  or ‘founder code’ are the same thing=1,  but now some of those layers share an interface=1, 7 encoding=1,  moving your images to a cdn and just changing the links to them=1,  sometimes it’s best just to give up and write a substantial amount of trashy code to hold the rest together=1,  roughly=1,  you got everything right=1,  […] hence plan to throw one away; you will=1,  other good examples of code you’re not going to delete are lists=1, the less specific the code is to your application or project=1,  the problem with code re=1,  or using a command line flag over a variable=1,  split your code=1, very line of code written comes at a price=1,  etc=1, off client sites=1,  but you are writing those lines of code in the easy=1,  failure happens more than success=1,  if we wish to count lines of code=1,  what feels like a simple change ends up touching almost every part of the code base in an ad=1,  but a multitude of objects you can operate on=1,  but it is much easier to replace=1,  we’re trying keep the parts that change frequently=1,  workflow=1,  rather than lock in your choice across the project=1,  handling change is not just developing new features but getting rid of old ones too=1,  the easier they are to re=1, [start] with a list of difficult design decisions or design decisions which are likely to change=1,  directory=1,  go and write a mess the first time=1,  a single util file will always grow until it is too big and yet too hard to split apart=1,  days=1, use=1, i have decided=1,  but you do want to try and keep your util directory free of business logic=1, use and the less likely to change or be deleted=1, use apis out of simpler=1,  a healthy code base has some verbosity=1,  managing how the code fits together=1, good code is easy to delete=1,  and maybe allow changing a few at runtime=1,  you learn nothing from success=1,  we often end up writing a lot more code through copy paste to use them=1,  but how to build software that can change over time=1,  this is the “save me from my standard library” stuff=1,  or processes=1,  a number of operations on sets=1,  maintain=1, a healthy code base doesn’t have to be perfectly modular=1,  microsoft windows has internal and external apis for this very purpose=1,  meanwhile=1,  i am ok with this=1, boilerplate works best when libraries are expected to cater to all tastes=1,  perfecting your mistakes=1,  it is not that you know what good code looks like=1,  even if we have to write boilerplate to use it=1,  gaining reliability by giving up when errors happen=1,  it took more than 25 years to get a way to move email from one folder to another that reliably works=1,  urllib3 does the pipelining=1, i don’t need to tell you that deleting code is more fun than writing it=1,  gain flexibility=1,  powered by a more verbose=1,  and layering is realising we can’t please everyone at once=1, delete=2, use is that it gets in the way of changing your mind later on=1,  and the code base involved in this case is not that=1, and=2,  and the internal api is tied to the underlying kernel=1,  it is easier to find something that works with sql over any homebrew query language=1,  “delete this directory”=1, fast and restart than it is to handle errors=1,  twitter’s finagle uses a common api for services=1,  and effort to replace=1, end principle argues that it is easier to handle failure at the far ends of a connection than anywhere in the middle=1,  armstrong=1, intuitive=1,  these can change halfway through the result of an operation too=1,  common interfaces=1, although the more code you have the harder it is to get rid of=1,  hiding these apis away gives microsoft flexibility without breaking too much software in the process=1,  saving one line of code saves absolutely nothing on its own=1, usable software=1, the code that calls your function will rely on both the intentional and the unintentional behaviours of the implementation behind it=1,  one of the most popular and beloved python http clients=1,  similarly=2,  so why bother handling them on the inside?=1,  we need to find a means to tease apart the logic atop=1,  but it’s a lot easier to explain what one looks like rather than how to build it in the first place=1,  and each other=1, it’s easier to delete all of the code than to delete it piecewise=1,  you’re probably re=1,  it made it more obvious when long running feature developement would impact other parts of the code=1,  and when a supervisor encounters a fault=1, business logic is code characterised by a never ending series of edge cases and quick and dirty hacks=1, implement but clumsy=1, write and the likely=1,  than foresight of ones you might want later=1,  neither breaks the browser=1, this is especially true of more fun or creative endeavours=1,  but isolating components for change=1,  we are lowering the cost of maintenance=1,  good examples of loose coupling are often examples of uniform interfaces=1, 000=3, use parts=1,  parnas=1,  and perhaps i could never succeed in intelligibly doing so=1,  “everything should be built top=1,  there is a special utf=1,  but making the hard to delete code pleasant to use (without contaminating it with business logic)=1,  500 5=1,  or functions with a little bit of global knowledge like environment variables=1,  each module is then designed to hide such a decision from the others=1, code that is loosely coupled isn’t necessarily easy=1,  this is known as the end=1,  2003=1,  don’t write code=1,  10=1,  don’t copy paste code=1,  it is not so much you are building modules to re=1,  good code isn’t about getting it right the first time=1,  event web pages=1,  layering is easiest when you start with a good api=1, (i’m sure if i didn’t mention the unix pipeline here someone would complain at me)=1, you don’t need to throw it all away but you will need to delete some of it=1,  making reliable distributed systems in the presence of software errors=1, pasting=1,  boilerplate=1,  it’s time to wrap your flexible library with one that has opinions on policy=1,  we should try to build disposable software=1,  then when we delete lines of code=1,  and a =1,  you don’t have to finish writing one library to start writing another atop=1,  25=1,  copy=1,  other styles like ‘game code’=1, libraries that require boilerplate are often stuff like network protocols=1,  writing code you can delete is working on the opposite assumption=1, it’s often good to wrap third party libraries too=1,  the external apis are tied to the lifecycle of desktop programs=1,  and decoupling feature releases from deploying code=1, to=16,  once you make something a shared api=1, monorepos are a similar tradeoff=1,  rather than the same bit over and over=1,  and it’s quicker to get it wrong a few times and iterate than think to get it right first time=1,  it’s a way of decoupling feature releases from merging branches=1,  is a significant problem in large scale systems=1,  this code is hard to delete=1,  minimising the dependencies or responsibilities of library code=1,  and frankly one large mistake is easier to deploy than 20 tightly coupled ones=1,  or delete away from each other=1,  but you change some of the code in a different place each time=1,  you will do that=1,  urllib3 is about giving you the tools to choose your own adventure=1, esque=1,  but writing a good api on top of a bad one is unpleasantly hard=1,  it’s quicker to write ten big balls of mud and see where it gets you than try to polish a single turd=1,  it isn’t so much that you should write microservices and not monoliths=1,  file handles=1,  and does not hide anything from the user=1,  ask any sre=1,  break your code into pieces=1,  and authentication checks to be added effortlessly to client and server code=1, i shall not today attempt further to define the kinds of material i understand to be embraced within that shorthand description [”loose coupling”]=1, use them=1,  if every layer atop must handle errors=1, error handling is one of the many ways in which a system can be tightly bound together=1, erlang=1,  both file systems and databases make much better examples of remote storage=1,  stuff where it’s hard to interweave policy (what a program should do)=1,  a lot of programming is exploratory=1,  don’t write boilerplate=1,  error handling like this may seem counter=1, even so=1,  cutting corners to save a considerable amount of time=1, catalogue of regrets and mistakes=1,  but i know it when i see it=1, this isn’t as uncommon as you might think=1,  putting a cache in front of your http server=1, it is not so much that we are hiding detail when we wrap one library in another=1,  there are many other examples of tight coupling=1,  it’s often a requirement for talking to another computer or handling different files=1, otp is relatively unique in how it chooses to handle failure=1,  library code like logging=1, instead of making code easy=1, i am not making any of this up=1, instead of breaking code into parts with common functionality=1,  you can cut a lot more corners=1, hoc fashion=1, the more consumers of an api you have=1,  imap generates unique tokens to identify each message=1,  requests=1, end principle=1, http has examples of loose coupling too=1,  each process in an erlang system is started by and watched by a supervisor=1,  the end=1,  as a result=1,  and protocol (what a program can do) together without limiting the options=1,  but we give it a different name=1,  you’ve composed=1, implement ones=1, you’ve copy=1,  this includes functions without any state=1,  build simple=1, use library urllib3 underneath=1,  with unique options and handling=1, by being able to turn the new code on=1, a feature flag isn’t just a command line switch=1,  except the first time”=1,  it follows the same pattern=1, it’s simpler to delete the code inside a function than it is to delete a function=1,  and recovery are best done at the outer layers of your code base=1,  larger changes could be broken down into smaller merges without impacting existing code=1,  but turning things off=1,  but because they don’t grow in scope over time=1,  with a file system=1,  doing so is easier said than done=1,  error handling is painful=1,  don’t hard code every choice=1, big balls of mud are the easiest to build but the most expensive to maintain=1,  using a single util file is unhygienic=1, delete parts=2, delete parts as far away as possible from the easy=1,  and the last thing we want to do is litter it with business logic=1,  write a big lump of code=1,  or where you fill in the gaps left by a framework=1,  or filters and pipelines=1,  just to get a handle on how it will be used=1,  don’t write a web framework before writing an application=1,  take new risks=1,  is a successful example of providing a simpler interface=1,  writing extensible code is hoping that in three months time=1,  requests is about popular http adventures=1, although sql may seem like a much broader interface than a filesystem=1,  we build reusable software=1,  we should not regard them as “lines produced” but as “lines spent” ewd 1036=1,  to avoid paying for a lot of code=1, unfortunately=1,  but you have a feedback loop=1, being able to write new code without dealing with old code makes it far easier to experiment with new ideas=1,  we break code apart by what it does not share with the rest=1, even hardcoding a variable once can be loose coupling=1, the strategies i’ve talked about — layering=1, it’s good to copy=1,  deleted=1,  we isolate the most frustrating parts to write=1, error handling=1,  and it gets harder as your project grows older=1,  scotus justice stewart=1,  good code is just legacy code that doesn’t get in the way=1, my point today is that=1,  anyhow=1, protocol=1,  you’ve refactored=1,  than two components requiring a careful co=1, on again has a knack for suppressing transient faults=1,  connection management=1,  or parsing kits=1,  but it is a little unfair to single one out as being badly designed=1,  and much easier to change too=1, this is not an exercise in code reuse=1,  common problems across web servers have unique codes=1, use libraries on top of simpler=1, for example=1,  although the single responsibility principle suggests that ‘each module should only handle one hard problem’=1,  but the code still has to do something at the end of the day=1,  but sometimes there is just too much duplication=1,  supervision trees=1,  isolation=1,  therefore=1, http’s error codes are another example of loose coupling=1,  it is more important that ‘each hard problem is only handled by one module’=1, deploying your software=1,  or easily replaced=1,  maintenance=1,  what was easy to delete as a whole is now impossible to delete piecewise=1,  you’ve layered=1,  not because they often have very simple interfaces=1,  or weeks to roll out new software=1,  wire formats=1,  but we are separating concerns=1,  but don’t repeat yourself to manage them=1,  write more boilerplate=1,  any system that can wake you up at night is one worth being able to control at runtime=1, paste code a couple of times=1, use apis is about turning your boilerplate into a library=1,  reluctantly to use latex=1, like with copy paste=1,  anything where you have a template and stamp out copies=1,  when a process exits=1,  make a util directory and keep different utilities in different files=1,  you make it harder to change=1, building reusable code is something that’s easier to do in hindsight with a couple of examples of use in the code base=1,  and a unique base64 encoding too=1}